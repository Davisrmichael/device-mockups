<!-- Your file picker -->
<input id="imageInput" type="file" accept="image/*">

<script type="module">
  const mv = document.getElementById('mv');
  const input = document.getElementById('imageInput');

  // Utility: find the "Screen" material once the model has loaded
  async function getScreenMaterial() {
    await mv.updateComplete;
    const mats = mv.model?.materials || [];
    return mats.find(m => (m.name || '').toLowerCase() === 'screen');
  }

  // Utility: draw an image file into a canvas (contain fit, centered)
  async function fileToFittedCanvas(file, targetW=1024, targetH=1024) {
    const bmp = await createImageBitmap(file);
    const canvas = document.createElement('canvas');
    canvas.width = targetW; 
    canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // Fill black first (so emissive looks clean)
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, targetW, targetH);

    // Contain fit math
    const scale = Math.min(targetW / bmp.width, targetH / bmp.height);
    const w = Math.round(bmp.width * scale);
    const h = Math.round(bmp.height * scale);
    const x = Math.round((targetW - w) / 2);
    const y = Math.round((targetH - h) / 2);

    ctx.drawImage(bmp, x, y, w, h);
    return canvas;
  }

  // Core: apply a canvas as texture to the Screen material (base + emissive)
  async function applyCanvasToScreen(canvas) {
    const scr = await getScreenMaterial();
    if (!scr) throw new Error('Screen material not found. Make sure the material is named exactly "Screen".');

    const tex = await mv.createTexture(canvas);

    // Make sure the base shows true colors
    if (scr.pbrMetallicRoughness?.setBaseColorFactor) {
      scr.pbrMetallicRoughness.setBaseColorFactor([1,1,1,1]);
    }

    // Base color slot (support both APIs)
    if (scr.pbrMetallicRoughness?.baseColorTexture?.setTexture) {
      scr.pbrMetallicRoughness.baseColorTexture.setTexture(tex);
    } else if (scr.pbrMetallicRoughness?.setBaseColorTexture) {
      scr.pbrMetallicRoughness.setBaseColorTexture(tex);
    }

    // Emissive slot (support both APIs)
    if (scr.emissiveTexture?.setTexture) {
      scr.emissiveTexture.setTexture(tex);
    } else if (typeof scr.setEmissiveTexture === 'function') {
      scr.setEmissiveTexture(tex);
    }

    // Emissive factor (support both APIs)
    if (typeof scr.setEmissiveFactor === 'function') {
      scr.setEmissiveFactor([1,1,1]);
    } else {
      scr.emissiveFactor = [1,1,1];
    }

    // Keep it matte
    if (scr.pbrMetallicRoughness) {
      scr.pbrMetallicRoughness.metallicFactor = 0.0;
      scr.pbrMetallicRoughness.roughnessFactor = 0.9;
    }
  }

  // Wire up the file input → canvas → texture pipeline
  input.addEventListener('change', async () => {
    const file = input.files?.[0];
    if (!file) return;
    try {
      // You can tweak target texture size here if you like
      const canvas = await fileToFittedCanvas(file, 2048, 2048);
      await applyCanvasToScreen(canvas);
      toast('Screen updated ✅');
    } catch (err) {
      console.error(err);
      toast('Failed to apply image. Try another file or refresh.', true);
    }
  });

  // Tiny toast helper
  function toast(msg, isErr=false) {
    let t = document.getElementById('toast');
    if (!t) {
      t = document.createElement('div');
      t.id = 'toast';
      Object.assign(t.style, {
        position:'fixed', left:'50%', bottom:'24px', transform:'translateX(-50%)',
        padding:'10px 14px', borderRadius:'10px', color:'#fff', font:'600 13px ui-sans-serif,system-ui',
        zIndex:'99999', boxShadow:'0 8px 24px rgba(0,0,0,.25)'
      });
      document.body.appendChild(t);
    }
    t.style.background = isErr ? '#e11d48' : '#16a34a';
    t.textContent = msg;
    t.style.opacity = '1';
    setTimeout(()=>{ t.style.transition='opacity .4s'; t.style.opacity='0'; }, 1600);
  }
</script>
