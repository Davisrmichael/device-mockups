<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>iPhone Mockup Maker</title>
<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
    background: #f0f0f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  model-viewer {
    width: 400px;
    height: 800px;
    background: transparent;
  }
  #controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 400px;
    width: 100%;
  }
  canvas {
    display: none;
  }
</style>
</head>
<body>

<h1>iPhone Mockup Maker</h1>

<model-viewer id="viewer"
  src="iPhone-15-Pro-converted/iphone_15_pro_max.gltf"
  camera-controls
  auto-rotate
  ar
  exposure="1"
  shadow-intensity="1">
</model-viewer>

<div id="controls">
  <input type="file" id="imageInput" accept="image/*" />
  <label>Zoom: <input type="range" id="zoom" min="0.5" max="2" step="0.01" value="1" /></label>
  <label>Pan X: <input type="range" id="panX" min="-1" max="1" step="0.01" value="0" /></label>
  <label>Pan Y: <input type="range" id="panY" min="-1" max="1" step="0.01" value="0" /></label>
  <label><input type="checkbox" id="flipX" /> Flip X</label>
  <label><input type="checkbox" id="flipY" /> Flip Y</label>
</div>

<canvas id="offscreen" width="1024" height="1024"></canvas>

<script type="module">
const viewer = document.getElementById('viewer');
const imageInput = document.getElementById('imageInput');
const zoomSlider = document.getElementById('zoom');
const panXSlider = document.getElementById('panX');
const panYSlider = document.getElementById('panY');
const flipXCheck = document.getElementById('flipX');
const flipYCheck = document.getElementById('flipY');
const offscreen = document.getElementById('offscreen');
const ctx = offscreen.getContext('2d');

let userImage = null;

async function applyCanvasToScreen() {
  const tex = new THREE.CanvasTexture(offscreen);
  tex.flipY = false;
  tex.needsUpdate = true;

  const model = viewer.model;
  if (!model) return;
  const screenMesh = model.getObjectByName('Screen') || model.getObjectByProperty('name', 'Screen');
  if (screenMesh && screenMesh.material) {
    screenMesh.material.map = tex;
    screenMesh.material.needsUpdate = true;
  }
}

function drawToCanvas() {
  if (!userImage?.bitmap) return;

  ctx.clearRect(0, 0, offscreen.width, offscreen.height);

  const iw = userImage.width;
  const ih = userImage.height;
  const canvasRatio = offscreen.width / offscreen.height;
  const imageRatio = iw / ih;

  let drawWidth, drawHeight;

  // Cover fit while preserving aspect ratio
  if (imageRatio > canvasRatio) {
    drawHeight = offscreen.height * zoomSlider.value;
    drawWidth = drawHeight * imageRatio;
  } else {
    drawWidth = offscreen.width * zoomSlider.value;
    drawHeight = drawWidth / imageRatio;
  }

  let dx = offscreen.width / 2 - drawWidth / 2 + panXSlider.value * offscreen.width / 2;
  let dy = offscreen.height / 2 - drawHeight / 2 - panYSlider.value * offscreen.height / 2;

  ctx.save();
  ctx.translate(offscreen.width / 2, offscreen.height / 2);
  ctx.scale(flipXCheck.checked ? -1 : 1, flipYCheck.checked ? -1 : 1);
  ctx.translate(-offscreen.width / 2, -offscreen.height / 2);
  ctx.drawImage(userImage.bitmap, dx, dy, drawWidth, drawHeight);
  ctx.restore();

  applyCanvasToScreen();
}

imageInput.addEventListener('change', async () => {
  const f = imageInput.files?.[0];
  if (!f) return;

  try {
    const bmp = await createImageBitmap(f, { imageOrientation: 'from-image' });
    userImage = { bitmap: bmp, width: bmp.width, height: bmp.height };
    drawToCanvas();
  } catch (e) {
    console.error('Image decode error', e);
    alert('Failed to load image file.');
  }
});

[zoomSlider, panXSlider, panYSlider, flipXCheck, flipYCheck]
  .forEach(el => el.addEventListener('input', drawToCanvas));

viewer.addEventListener('load', () => {
  if (userImage) drawToCanvas();
});
</script>

</body>
</html>
