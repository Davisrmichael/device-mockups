<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mockup Maker</title>
  <style>
    :root { --panel: #f5f7fb; --ink:#0f172a; --muted:#475569; --ring:#e5e7eb; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background:#eceff3; color: var(--ink); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
    .wrap { display: grid; grid-template-columns: 320px 1fr; gap: 16px; height: 100%; padding: 16px; }
    aside { background: var(--panel); border:1px solid var(--ring); border-radius: 12px; padding: 16px; overflow:auto; }
    h1 { font-size: 16px; margin: 0 0 12px; }
    .section { margin: 14px 0 18px; }
    label { display:block; font-weight:600; margin-bottom:8px; }
    .row { display:flex; gap:8px; align-items:center; }
    button, .btn {
      appearance: none; border:1px solid var(--ring); background:white; padding:8px 12px;
      border-radius:10px; cursor:pointer; font-weight:600;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input[type="checkbox"] { transform: translateY(1px); }
    .muted { color: var(--muted); font-size: 12px; }
    .status { margin-top:10px; min-height: 20px; font-size: 12px; color: var(--muted); }
    main { background:white; border:1px solid var(--ring); border-radius: 12px; display:grid; place-items:center; }
    model-viewer { width: 100%; height: 100%; --poster-color: transparent; }
    /* hidden work canvas (kept for debugging if needed) */
    #work { position: fixed; inset: 12px auto auto 12px; width:120px; height:auto; opacity:.08; pointer-events:none; display:none; }
  </style>
  <!-- model-viewer (stable) -->
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>
  <div class="wrap">
    <aside>
      <h1>Mockup Maker</h1>
      <div class="section">
        <label>Screen Texture</label>
        <div class="row">
          <button id="choose">Choose Image…</button>
          <button id="clear">Clear</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="bright" type="checkbox" checked />
          <label for="bright" style="font-weight:500;margin:0;">Bright (emissive)</label>
        </div>
        <div class="muted" style="margin-top:8px;">
          Targets material named <b>Screen</b>. Image is drawn with <b>cover</b> and equal X/Y scale.  
          Auto Y-flip so it isn’t upside down.
        </div>
        <div class="status" id="status">Waiting for image…</div>
      </div>
    </aside>

    <main>
      <model-viewer id="mv"
        src="iPhone-15-pro-2/iPhone-15.gltf"
        exposure="1.0"
        camera-controls
        disable-zoom
        ar
        ar-modes="webxr scene-viewer quick-look"
        tone-mapping="neutral"
        shadow-intensity="0">
      </model-viewer>
    </main>
  </div>

  <!-- hidden canvas sized to the real screen aspect to avoid any warping -->
  <canvas id="work" width="1179" height="2556"></canvas>

<script>
(() => {
  const mv = document.getElementById('mv');
  const chooseBtn = document.getElementById('choose');
  const clearBtn  = document.getElementById('clear');
  const brightChk = document.getElementById('bright');
  const statusEl  = document.getElementById('status');
  const work = document.getElementById('work');

  // iPhone 15 Pro logical screen pixels (portrait) – keeps correct aspect
  const SCREEN_W = 1179, SCREEN_H = 2556;

  function setStatus(msg, ok=true){
    statusEl.textContent = msg;
    statusEl.style.color = ok ? '#475569' : '#b91c1c';
  }

  async function pickFile() {
    return new Promise(resolve => {
      const i = document.createElement('input');
      i.type = 'file';
      i.accept = 'image/*';
      i.onchange = () => resolve(i.files && i.files[0]);
      i.click();
    });
  }

  function drawCoverToCanvas(bitmap, canvas) {
    const ctx = canvas.getContext('2d');
    const dw = canvas.width = SCREEN_W;
    const dh = canvas.height = SCREEN_H;

    const sw = bitmap.width;
    const sh = bitmap.height;
    const scale = Math.max(dw / sw, dh / sh); // object-fit: cover
    const tw = sw * scale;
    const th = sh * scale;
    const ox = (dw - tw) / 2;
    const oy = (dh - th) / 2;

    ctx.clearRect(0,0,dw,dh);
    // Flip Y so the texture appears correctly on the model
    ctx.save();
    ctx.translate(0, dh);
    ctx.scale(1, -1);
    ctx.drawImage(bitmap, ox, oy, tw, th);
    ctx.restore();
  }

  async function applyCanvasToScreen(canvas) {
    await mv.updateComplete;

    const scr = mv.model?.materials?.find(m => m.name === 'Screen');
    if (!scr) { setStatus('Screen material not found in model.', false); return; }

    // Create a blob URL for the canvas to avoid the [object HTMLCanvasElement] fetch 404
    const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
    const url = URL.createObjectURL(blob);

    try {
      const tex = await mv.createTexture(url);

      // Prefer emissive for screens (brighter, unaffected by lighting)
      const useEmissive = brightChk.checked;

      if (useEmissive) {
        if (scr.emissiveTexture?.setTexture) scr.emissiveTexture.setTexture(tex);
        else if (scr.setEmissiveTexture)     scr.setEmissiveTexture(tex);
        else if (scr.pbrMetallicRoughness?.baseColorTexture?.setTexture)
          scr.pbrMetallicRoughness.baseColorTexture.setTexture(tex);
        else if (scr.pbrMetallicRoughness?.setBaseColorTexture)
          scr.pbrMetallicRoughness.setBaseColorTexture(tex);

        if (typeof scr.setEmissiveFactor === 'function') scr.setEmissiveFactor([1,1,1]);
        else scr.emissiveFactor = [1,1,1];

        scr.pbrMetallicRoughness?.setMetallicFactor?.(0.0);
        scr.pbrMetallicRoughness?.setRoughnessFactor?.(0.9);
      } else {
        if (scr.pbrMetallicRoughness?.baseColorTexture?.setTexture)
          scr.pbrMetallicRoughness.baseColorTexture.setTexture(tex);
        else if (scr.pbrMetallicRoughness?.setBaseColorTexture)
          scr.pbrMetallicRoughness.setBaseColorTexture(tex);
      }

      setStatus('✅ Screen updated.');
    } catch (err) {
      console.error(err);
      setStatus('Failed to apply image. Try another file / refresh.', false);
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  async function handleChoose() {
    try {
      const file = await pickFile();
      if (!file) return;
      setStatus('Loading image…');

      // Respect EXIF orientation by asking the browser to decode with it applied
      const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });

      drawCoverToCanvas(bmp, work);
      await applyCanvasToScreen(work);
    } catch (e) {
      console.error(e);
      setStatus('Failed to load that image.', false);
    }
  }

  async function handleClear() {
    try {
      await mv.updateComplete;
      const scr = mv.model?.materials?.find(m => m.name === 'Screen');
      if (!scr) return;

      // Remove textures safely across versions
      if (scr.emissiveTexture?.setTexture) scr.emissiveTexture.setTexture(null);
      if (typeof scr.setEmissiveTexture === 'function') scr.setEmissiveTexture(null);
      const pmr = scr.pbrMetallicRoughness;
      if (pmr?.baseColorTexture?.setTexture) pmr.baseColorTexture.setTexture(null);
      if (pmr?.setBaseColorTexture) pmr.setBaseColorTexture(null);

      setStatus('Screen cleared.');
    } catch (e) {
      console.error(e);
      setStatus('Could not clear screen.', false);
    }
  }

  chooseBtn.addEventListener('click', handleChoose);
  clearBtn.addEventListener('click', handleClear);

  mv.addEventListener('load', () => setStatus('Model loaded. Choose an image to begin.'));
  mv.addEventListener('error', (e) => {
    console.error(e);
    setStatus('Model failed to load. Check path: iPhone-15-pro-2/iPhone-15.gltf', false);
  });
})();
</script>
</body>
</html>
