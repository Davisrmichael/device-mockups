<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mockup Maker — iPhone</title>
<script type="module" src="https://unpkg.com/@google/model-viewer@3.3.0/dist/model-viewer.min.js"></script>
<style>
  :root{--bg:#eef1f4;--panel:#fff;--ink:#0f172a;--muted:#64748b;--line:#e5e7eb;--btn:#111827}
  html,body{height:100%} body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .grid{display:grid;grid-template-columns:340px 1fr;gap:16px;padding:16px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:16px;display:flex;flex-direction:column;gap:14px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .hint{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%}
  button{border:0;background:var(--btn);color:#fff;border-radius:10px;padding:10px 12px;font-weight:600;cursor:pointer}
  .ghost{background:#e5e7eb;color:#111827}
  model-viewer{width:100%;height:calc(100vh - 32px);--poster-color:transparent;background:#e9edf1;border:1px solid var(--line);border-radius:14px}
  #err{color:#b91c1c;font-size:12px;white-space:pre-wrap}
</style>
</head>
<body>
<div class="grid">
  <aside class="panel">
    <h3 style="margin:0">Screen Texture</h3>
    <div class="row">
      <input id="file" type="file" accept="image/*">
      <label><input type="checkbox" id="emissive" checked> Bright (emissive)</label>
    </div>
    <div class="row"><label class="hint">Zoom</label><input id="zoom" type="range" min="0.5" max="2.0" step="0.01" value="1.00"></div>
    <div class="row"><label class="hint">Pan X</label><input id="panx" type="range" min="-1" max="1" step="0.005" value="0"></div>
    <div class="row"><label class="hint">Pan Y</label><input id="pany" type="range" min="-1" max="1" step="0.005" value="0"></div>
    <div class="row"><label><input type="checkbox" id="flipx"> Flip X</label><label><input type="checkbox" id="flipy"> Flip Y</label></div>
    <div class="row"><button id="front" class="ghost">Front-on</button><button id="reset" class="ghost">Reset</button></div>
    <div class="hint">Targets material named <code>Screen</code>. Image is fitted with “cover” and preserves aspect ratio; pan/zoom adjust the crop.</div>
    <div id="err"></div>
  </aside>

  <model-viewer id="mv" camera-controls environment-image="neutral" tone-mapping="neutral"
                interaction-prompt="none" shadow-intensity="0"></model-viewer>
</div>

<script type="module">
const mv = document.getElementById('mv');
const errBox = document.getElementById('err');

// ---- choose model (default to your iPhone path) ----
const DEFAULT_MODEL = 'iPhone-15-pro-2/iPhone-15.gltf';
const urlModel = new URLSearchParams(location.search).get('model');
mv.src = urlModel || DEFAULT_MODEL;

// ---- UI refs ----
const file = document.getElementById('file');
const zoom = document.getElementById('zoom');
const panx = document.getElementById('panx');
const pany = document.getElementById('pany');
const flipx = document.getElementById('flipx');
const flipy = document.getElementById('flipy');
const emissive = document.getElementById('emissive');
document.getElementById('front').onclick = ()=> setOrbit(0,0,2.6);
document.getElementById('reset').onclick = ()=>{ zoom.value=1; panx.value=0; pany.value=0; flipx.checked=false; flipy.checked=false; if(lastImg) applyFrom(lastImg); };

// ---- camera helpers ----
function setOrbit(thetaDeg, tiltDeg, radius=2.6){
  const phi = 90 - tiltDeg;
  mv.cameraOrbit = `${thetaDeg}deg ${phi}deg ${radius}m`;
}

// ---- image -> canvas (cover fit) ----
const cvs = document.createElement('canvas');
cvs.width = 2048; cvs.height = 2048; // plenty of res for a crisp screen
const ctx = cvs.getContext('2d');

function drawToCanvas(img){
  const W = cvs.width, H = cvs.height;
  ctx.clearRect(0,0,W,H);
  ctx.save();

  // flips
  ctx.translate(W/2, H/2);
  ctx.scale(flipx.checked ? -1 : 1, flipy.checked ? -1 : 1);
  ctx.translate(-W/2, -H/2);

  // cover fit
  const iw = img.naturalWidth, ih = img.naturalHeight;
  const s = parseFloat(zoom.value);
  const scale = Math.max(W/iw, H/ih) * s;
  const dw = iw * scale, dh = ih * scale;

  const px = parseFloat(panx.value), py = parseFloat(pany.value); // -1..1
  const cx = W/2 + px * (W/2 - 1);
  const cy = H/2 + py * (H/2 - 1);

  const dx = cx - dw/2;
  const dy = cy - dh/2;

  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(img, dx, dy, dw, dh);
  ctx.restore();
}

async function applyCanvasToMaterial(){
  const mat = mv.model?.materials?.find(m => m.name === 'Screen');
  if(!mat){ throw new Error('Material "Screen" not found'); }

  // ensure base is neutral white so uploaded colors aren’t tinted
  if (mat.pbrMetallicRoughness?.setBaseColorFactor) {
    mat.pbrMetallicRoughness.setBaseColorFactor([1,1,1,1]);
  } else if (mat.pbrMetallicRoughness) {
    mat.pbrMetallicRoughness.baseColorFactor = [1,1,1,1];
  }

  const tex = await mv.createTexture(cvs);

  // baseColor (version-safe)
  const bc = mat.pbrMetallicRoughness?.baseColorTexture;
  if (bc?.setTexture) bc.setTexture(tex);
  else if (mat.pbrMetallicRoughness?.setBaseColorTexture) mat.pbrMetallicRoughness.setBaseColorTexture(tex);

  // emissive (version-safe)
  if (emissive.checked) {
    if (mat.emissiveTexture?.setTexture) mat.emissiveTexture.setTexture(tex);
    else if (typeof mat.setEmissiveTexture === 'function') mat.setEmissiveTexture(tex);

    if (typeof mat.setEmissiveFactor === 'function') mat.setEmissiveFactor([1,1,1]);
    else mat.emissiveFactor = [1,1,1];
  } else {
    if (mat.emissiveTexture?.setTexture) mat.emissiveTexture.setTexture(null);
    else if (typeof mat.setEmissiveTexture === 'function') mat.setEmissiveTexture(null);
    if (typeof mat.setEmissiveFactor === 'function') mat.setEmissiveFactor([0,0,0]);
    else mat.emissiveFactor = [0,0,0];
  }

  // keep it matte
  if (mat.pbrMetallicRoughness) {
    try { mat.pbrMetallicRoughness.metallicFactor = 0.0; } catch {}
    try { mat.pbrMetallicRoughness.roughnessFactor = 0.9; } catch {}
  }
}

let lastImg = null;
async function applyFrom(img){
  try{
    errBox.textContent = '';
    await mv.updateComplete;
    drawToCanvas(img);
    await applyCanvasToMaterial();
  }catch(e){
    errBox.textContent = `Failed to apply image: ${e.message}`;
    console.error(e);
  }
}

// file input
file.addEventListener('change', ()=>{
  const f = file.files?.[0]; if(!f) return;
  const img = new Image(); img.crossOrigin = 'anonymous';
  img.onload = ()=>{ lastImg = img; applyFrom(img); };
  img.onerror = ev => { errBox.textContent = 'Image failed to load (check type/permissions)'; console.error('error', ev); };
  img.src = URL.createObjectURL(f);
});

// controls re-apply
[zoom, panx, pany, flipx, flipy, emissive].forEach(el => el.addEventListener('input', ()=>{ if(lastImg) applyFrom(lastImg); }));

// set a sensible starting camera (front-on)
mv.addEventListener('load', ()=> setOrbit(0,0,2.6));
</script>
</body>
</html>
