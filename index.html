<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mockup Maker</title>
  <style>
    :root { --panel:#f5f7fb; --ink:#0f172a; --muted:#475569; --ring:#e5e7eb; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#eceff3;color:var(--ink);font:14px/1.4 system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100%;padding:16px}
    aside{background:var(--panel);border:1px solid var(--ring);border-radius:12px;padding:16px;overflow:auto}
    h1{font-size:16px;margin:0 0 12px}
    .section{margin:14px 0 18px}
    label{display:block;font-weight:600;margin-bottom:8px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{appearance:none;border:1px solid var(--ring);background:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type="checkbox"]{transform:translateY(1px)}
    .muted{color:var(--muted);font-size:12px}
    .status{margin-top:10px;min-height:20px;font-size:12px;color:var(--muted)}
    main{background:white;border:1px solid var(--ring);border-radius:12px;display:grid;place-items:center}
    model-viewer{width:100%;height:100%;--poster-color:transparent}
    /* debug: hidden work canvas we draw into (screen only) */
    #work{position:fixed;inset:12px auto auto 12px;width:120px;height:auto;opacity:.08;pointer-events:none;display:none}
  </style>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
</head>
<body>
  <div class="wrap">
    <aside>
      <h1>Mockup Maker</h1>

      <div class="section">
        <label>Screen Texture</label>
        <div class="row">
          <button id="choose">Choose Image…</button>
          <button id="clear">Clear</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="bright" type="checkbox" checked />
          <label for="bright" style="font-weight:500;margin:0;">Bright (emissive)</label>
        </div>
        <div class="muted" style="margin-top:8px;">
          Targets material named <b>Screen</b>. Image is drawn with <b>cover</b>, equal X/Y scale, and auto Y-flip.
        </div>
      </div>

      <div class="section">
        <label>Export</label>
        <div class="row">
          <button id="export">Export PNG</button>
          <span class="muted" id="exportHint">Snapshots the viewport; falls back to screen image if needed.</span>
        </div>
      </div>

      <div class="status" id="status">Waiting for image…</div>
    </aside>

    <main>
      <model-viewer id="mv"
        src="iPhone-15-pro-2/iPhone-15.gltf"
        exposure="1.0"
        camera-controls
        disable-zoom
        tone-mapping="neutral"
        shadow-intensity="0"
        camera-orbit="180deg 90deg auto"   <!-- start rotated 180° -->
        >
      </model-viewer>
    </main>
  </div>

  <!-- hidden canvas sized to the real screen aspect to avoid any warping -->
  <canvas id="work" width="1179" height="2556"></canvas>

<script>
(() => {
  const mv = document.getElementById('mv');
  const chooseBtn = document.getElementById('choose');
  const clearBtn  = document.getElementById('clear');
  const exportBtn = document.getElementById('export');
  const brightChk = document.getElementById('bright');
  const statusEl  = document.getElementById('status');
  const work      = document.getElementById('work');

  // iPhone 15 Pro logical screen pixels (portrait) – keeps correct aspect
  const SCREEN_W = 1179, SCREEN_H = 2556;

  function setStatus(msg, ok=true){
    statusEl.textContent = msg;
    statusEl.style.color = ok ? '#475569' : '#b91c1c';
  }

  async function pickFile() {
    return new Promise(resolve => {
      const i = document.createElement('input');
      i.type = 'file';
      i.accept = 'image/*';
      i.onchange = () => resolve(i.files && i.files[0]);
      i.click();
    });
  }

  function drawCoverToCanvas(bitmap, canvas) {
    const ctx = canvas.getContext('2d');
    const dw = canvas.width = SCREEN_W;
    const dh = canvas.height = SCREEN_H;

    const sw = bitmap.width;
    const sh = bitmap.height;
    const scale = Math.max(dw / sw, dh / sh); // object-fit: cover
    const tw = sw * scale;
    const th = sh * scale;
    const ox = (dw - tw) / 2;
    const oy = (dh - th) / 2;

    ctx.clearRect(0,0,dw,dh);
    // Flip Y so the texture appears correctly on the model
    ctx.save();
    ctx.translate(0, dh);
    ctx.scale(1, -1);
    ctx.drawImage(bitmap, ox, oy, tw, th);
    ctx.restore();
  }

  async function applyCanvasToScreen(canvas) {
    await mv.updateComplete;

    const scr = mv.model?.materials?.find(m => m.name === 'Screen');
    if (!scr) { setStatus('Screen material not found in model.', false); return; }

    // Use a blob URL for the canvas to avoid [object HTMLCanvasElement] fetches
    const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
    const url = URL.createObjectURL(blob);

    try {
      const tex = await mv.createTexture(url);

      const useEmissive = brightChk.checked;

      if (useEmissive) {
        if (scr.emissiveTexture?.setTexture) scr.emissiveTexture.setTexture(tex);
        else if (scr.setEmissiveTexture)     scr.setEmissiveTexture(tex);
        else if (scr.pbrMetallicRoughness?.baseColorTexture?.setTexture)
          scr.pbrMetallicRoughness.baseColorTexture.setTexture(tex);
        else if (scr.pbrMetallicRoughness?.setBaseColorTexture)
          scr.pbrMetallicRoughness.setBaseColorTexture(tex);

        if (typeof scr.setEmissiveFactor === 'function') scr.setEmissiveFactor([1,1,1]);
        else scr.emissiveFactor = [1,1,1];

        scr.pbrMetallicRoughness?.setMetallicFactor?.(0.0);
        scr.pbrMetallicRoughness?.setRoughnessFactor?.(0.9);
      } else {
        if (scr.pbrMetallicRoughness?.baseColorTexture?.setTexture)
          scr.pbrMetallicRoughness.baseColorTexture.setTexture(tex);
        else if (scr.pbrMetallicRoughness?.setBaseColorTexture)
          scr.pbrMetallicRoughness.setBaseColorTexture(tex);
      }

      setStatus('✅ Screen updated.');
    } catch (err) {
      console.error(err);
      setStatus('Failed to apply image. Try another file / refresh.', false);
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  async function handleChoose() {
    try {
      const file = await pickFile();
      if (!file) return;
      setStatus('Loading image…');

      const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
      drawCoverToCanvas(bmp, work);
      await applyCanvasToScreen(work);
    } catch (e) {
      console.error(e);
      setStatus('Failed to load that image.', false);
    }
  }

  async function handleClear() {
    try {
      await mv.updateComplete;
      const scr = mv.model?.materials?.find(m => m.name === 'Screen');
      if (!scr) return;

      if (scr.emissiveTexture?.setTexture) scr.emissiveTexture.setTexture(null);
      if (typeof scr.setEmissiveTexture === 'function') scr.setEmissiveTexture(null);
      const pmr = scr.pbrMetallicRoughness;
      if (pmr?.baseColorTexture?.setTexture) pmr.baseColorTexture.setTexture(null);
      if (pmr?.setBaseColorTexture) pmr.setBaseColorTexture(null);

      setStatus('Screen cleared.');
    } catch (e) {
      console.error(e);
      setStatus('Could not clear screen.', false);
    }
  }

  async function handleExport() {
    setStatus('Exporting…');
    try {
      // Best: snapshot the whole 3D view (if supported by this model-viewer build)
      if (typeof mv.toBlob === 'function') {
        const blob = await mv.toBlob({ mimeType: 'image/png' });
        if (blob) return saveBlob(blob, 'mockup.png');
      }
      // Fallback: export just the screen image (work canvas)
      const blob = await new Promise(r => work.toBlob(r, 'image/png'));
      saveBlob(blob, 'mockup-screen.png');
    } catch (e) {
      console.error(e);
      setStatus('Export failed.', false);
      return;
    }
    setStatus('✅ Exported.');
  }

  function saveBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // UI wires
  chooseBtn.addEventListener('click', handleChoose);
  clearBtn .addEventListener('click', handleClear);
  exportBtn.addEventListener('click', handleExport);

  mv.addEventListener('load', () => setStatus('Model loaded. Choose an image to begin.'));
  mv.addEventListener('error', (e) => {
    console.error(e);
    setStatus('Model failed to load. Check path: iPhone-15-pro-2/iPhone-15.gltf', false);
  });
})();
</script>
</body>
</html>
