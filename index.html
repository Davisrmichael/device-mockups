<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mockup Maker</title>
<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
  body { font-family: sans-serif; margin: 0; padding: 0; background: #222; color: #fff; display: flex; flex-direction: column; align-items: center; }
  model-viewer { width: 100%; height: 80vh; background-color: #444; }
  .controls { padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; }
  input[type="range"] { width: 150px; }
  button { padding: 5px 10px; cursor: pointer; }
</style>
</head>
<body>

<model-viewer id="mv" 
  src="iphone_15_pro_max.gltf"
  camera-controls
  exposure="1"
  environment-image="neutral"
  shadow-intensity="1">
</model-viewer>

<div class="controls">
  <input type="file" id="imageInput" accept="image/*" style="display:none" />
  <button id="chooseImage">Choose Image</button>
  <label>Zoom <input type="range" id="zoom" min="0.5" max="2" step="0.01" value="1"></label>
  <label>Pan X <input type="range" id="panX" min="-1" max="1" step="0.01" value="0"></label>
  <label>Pan Y <input type="range" id="panY" min="-1" max="1" step="0.01" value="0"></label>
  <label><input type="checkbox" id="emissiveOn"> Emissive</label>
  <button id="clearImage" disabled>Clear</button>
</div>

<script type="module">
const mv = document.getElementById('mv');
const imageInput = document.getElementById('imageInput');
const chooseImage = document.getElementById('chooseImage');
const zoom = document.getElementById('zoom');
const panX = document.getElementById('panX');
const panY = document.getElementById('panY');
const emissiveOn = document.getElementById('emissiveOn');
const clearImage = document.getElementById('clearImage');

let screenMat = null;
const off = document.createElement('canvas');
off.width = off.height = 720;
let loadedImageEl = null;

mv.addEventListener('load', () => {
  const scene = mv.model;
  if (!scene) return;
  const allMats = [];
  scene.materials.forEach(m => allMats.push(m));
  // Pick first material containing "screen" in name
  screenMat = allMats.find(m => m.name.toLowerCase().includes('screen')) || allMats[0];
});

function drawCoverToCanvasFromImageElement(imageEl){
  const ctx = off.getContext('2d');
  ctx.clearRect(0,0,off.width,off.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,off.width,off.height);

  const Z  = parseFloat(zoom.value) || 1.0;
  const sw = imageEl.naturalWidth;
  const sh = imageEl.naturalHeight;
  const dw = off.width, dh = off.height;

  const scale = Math.max(dw/sw, dh/sh) * Z;  // COVER with uniform scale
  const tw = sw * scale, th = sh * scale;

  const overflowX = Math.max(0, tw - dw);
  const overflowY = Math.max(0, th - dh);
  const px = (parseFloat(panX.value)||0) * 0.5 * overflowX;
  const py = (parseFloat(panY.value)||0) * 0.5 * overflowY;

  const dx = (dw - tw)/2 + px;
  const dy = (dh - th)/2 + py;

  // Flip vertically so it matches glTF UVs
  ctx.save();
  ctx.translate(0, dh);
  ctx.scale(1, -1);
  ctx.drawImage(imageEl, dx, dh - dy - th, tw, th);
  ctx.restore();
}

async function applyCanvasToScreen(){
  if(!screenMat){ console.warn('Screen not ready'); return; }
  try{
    await mv.updateComplete;
    const tex = await mv.createTexture(off); // pass the canvas directly

    const pbr = screenMat.pbrMetallicRoughness;
    pbr?.setBaseColorFactor?.([1,1,1,1]);
    if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(tex);
    else if (pbr?.setBaseColorTexture)     pbr.setBaseColorTexture(tex);

    if (emissiveOn.checked){
      if (typeof screenMat.setEmissiveTexture === 'function') screenMat.setEmissiveTexture(tex);
      else screenMat.emissiveTexture?.setTexture?.(tex);
      if (typeof screenMat.setEmissiveFactor === 'function') screenMat.setEmissiveFactor([1,1,1]);
      else screenMat.emissiveFactor = [1,1,1];
    } else {
      if (typeof screenMat.setEmissiveTexture === 'function') screenMat.setEmissiveTexture(null);
      else screenMat.emissiveTexture?.setTexture?.(null);
      if (typeof screenMat.setEmissiveFactor === 'function') screenMat.setEmissiveFactor([0,0,0]);
      else screenMat.emissiveFactor = [0,0,0];
    }

    pbr?.setMetallicFactor?.(0.0);
    pbr?.setRoughnessFactor?.(0.9);

    clearImage.disabled = false;
  }catch(e){
    console.error(e);
  }
}

chooseImage.addEventListener('click', ()=> imageInput.click());
imageInput.addEventListener('change', async ()=>{
  const f = imageInput.files?.[0];
  if(!f) return;

  try{
    const reader = new FileReader();
    reader.onload = async () => {
      const img = new Image();
      img.decoding = 'sync';
      img.crossOrigin = 'anonymous';
      img.onload = async () => {
        loadedImageEl = img;
        drawCoverToCanvasFromImageElement(img);
        await applyCanvasToScreen();
      };
      img.onerror = (e)=>{ console.error('img error', e); };
      img.src = reader.result;
    };
    reader.readAsDataURL(f);
  }catch(err){
    console.error(err);
  }
});

[zoom,panX,panY,emissiveOn].forEach(el=> el.addEventListener('input', ()=>{
  if(loadedImageEl){
    drawCoverToCanvasFromImageElement(loadedImageEl);
    applyCanvasToScreen();
  }
}));

clearImage.addEventListener('click', ()=>{
  if(!screenMat) return;
  const pbr = screenMat.pbrMetallicRoughness;
  if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(null);
  else if (pbr?.setBaseColorTexture)     pbr.setBaseColorTexture(null);
  screenMat.emissiveTexture?.setTexture?.(null);
  clearImage.disabled = true;
});
</script>

</body>
</html>

