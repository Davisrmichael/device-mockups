<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mockup Maker</title>
<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
  :root { color-scheme: dark; }
  body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#222; color:#fff; }
  .wrap { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
  @media (max-width:900px){ .wrap{ grid-template-columns:1fr; } }
  model-viewer { width:100%; height:78vh; background:#2f2f2f; border-radius:12px; }
  .panel { background:#1b1b1b; border:1px solid #333; border-radius:12px; padding:14px; position:sticky; top:16px; height:fit-content; }
  .row { display:flex; align-items:center; gap:10px; margin:10px 0; }
  .row label { width:80px; color:#bbb; font-size:12px; }
  input[type="range"] { width:160px; }
  button { padding:8px 10px; border-radius:8px; border:1px solid #3a3a3a; background:#2a2a2a; color:#fff; cursor:pointer; }
  button[disabled]{ opacity:.5; cursor:not-allowed; }
  small{ color:#9aa; display:block; margin-top:8px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row">
        <button id="choose">Choose Image…</button>
        <button id="clear" disabled>Clear</button>
        <input id="file" type="file" accept="image/*" hidden />
      </div>

      <div class="row"><label>Zoom</label><input id="zoom" type="range" min="0.5" max="2" step="0.01" value="1.0"></div>
      <div class="row"><label>Pan X</label><input id="panX" type="range" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><label>Pan Y</label><input id="panY" type="range" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><label>Emissive</label><input id="emissive" type="checkbox"></div>

      <small>Fit mode is <b>cover</b> (uniform scale). Use Pan X/Y to reframe.</small>
      <small id="status"></small>
    </div>

    <model-viewer id="mv"
      src="iPhone-15-pro-2/iPhone-15.gltf"
      camera-controls
      environment-image="neutral"
      shadow-intensity="1"
      exposure="1.0">
    </model-viewer>
  </div>

<script type="module">
const mv = document.querySelector('#mv');
const choose = document.querySelector('#choose');
const clearBtn = document.querySelector('#clear');
const file = document.querySelector('#file');
const zoom = document.querySelector('#zoom');
const panX = document.querySelector('#panX');
const panY = document.querySelector('#panY');
const emissive = document.querySelector('#emissive');
const statusEl = document.querySelector('#status');

// Offscreen canvas we draw into (also becomes the GL texture)
const canvas = document.createElement('canvas');
canvas.width = canvas.height = 720;

let screenMat = null;
let imgEl = null;          // holds the uploaded image element
let objectUrl = null;      // for revoking after use

mv.addEventListener('load', () => {
  // Find the screen material by name (we expect "Screen")
  const mats = [];
  mv.model?.materials.forEach(m => mats.push(m));
  screenMat =
    mats.find(m => (m.name||'').toLowerCase() === 'screen') ||
    mats.find(m => (m.name||'').includes('Screen')) ||
    mats[0];

  if (!screenMat) {
    status('Could not find a "Screen" material in the model.');
  } else {
    status('Model ready. Pick an image to place on Screen.');
  }
});

function status(msg){ statusEl.textContent = msg || ''; }

// Draw the uploaded <img> into the canvas using COVER fit, locked XY scale, with pan
function drawCoverToCanvas() {
  if (!imgEl) return;
  const ctx = canvas.getContext('2d');
  const dw = canvas.width, dh = canvas.height;

  ctx.clearRect(0,0,dw,dh);
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,dw,dh);

  const sw = imgEl.naturalWidth;
  const sh = imgEl.naturalHeight;
  const Z = parseFloat(zoom.value) || 1.0;

  const scale = Math.max(dw/sw, dh/sh) * Z;    // COVER, uniform scale
  const tw = sw * scale, th = sh * scale;

  const overflowX = Math.max(0, tw - dw);
  const overflowY = Math.max(0, th - dh);
  const px = (parseFloat(panX.value)||0) * 0.5 * overflowX;
  const py = (parseFloat(panY.value)||0) * 0.5 * overflowY;

  const dx = (dw - tw)/2 + px;
  const dy = (dh - th)/2 + py;

  // Flip vertically so the texture is not upside-down in UV space
  ctx.save();
  ctx.translate(0, dh);
  ctx.scale(1, -1);
  ctx.drawImage(imgEl, dx, dh - dy - th, tw, th);
  ctx.restore();
}

async function applyCanvasToScreen() {
  if (!screenMat) { status('Screen not ready'); return; }
  await mv.updateComplete;

  const tex = await mv.createTexture(canvas);

  // Ensure white base so colors show true
  const pbr = screenMat.pbrMetallicRoughness;
  pbr?.setBaseColorFactor?.([1,1,1,1]);
  if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(tex);
  else if (pbr?.setBaseColorTexture)     pbr.setBaseColorTexture(tex);

  if (emissive.checked) {
    if (typeof screenMat.setEmissiveTexture === 'function') screenMat.setEmissiveTexture(tex);
    else screenMat.emissiveTexture?.setTexture?.(tex);
    if (typeof screenMat.setEmissiveFactor === 'function') screenMat.setEmissiveFactor([1,1,1]);
    else screenMat.emissiveFactor = [1,1,1];
  } else {
    if (typeof screenMat.setEmissiveTexture === 'function') screenMat.setEmissiveTexture(null);
    else screenMat.emissiveTexture?.setTexture?.(null);
    if (typeof screenMat.setEmissiveFactor === 'function') screenMat.setEmissiveFactor([0,0,0]);
    else screenMat.emissiveFactor = [0,0,0];
  }

  // Nice, matte look
  pbr?.setMetallicFactor?.(0.0);
  pbr?.setRoughnessFactor?.(0.9);

  clearBtn.disabled = false;
  status('Image applied ✔︎');
}

function revokeOldUrl(){
  if (objectUrl) { URL.revokeObjectURL(objectUrl); objectUrl = null; }
}

choose.addEventListener('click', () => file.click());

file.addEventListener('change', () => {
  const f = file.files?.[0];
  if (!f) return;

  try {
    revokeOldUrl();
    imgEl = new Image();
    imgEl.decoding = 'sync';
    objectUrl = URL.createObjectURL(f);       // ✅ correct way – NOT the canvas!
    imgEl.onload = async () => {
      drawCoverToCanvas();
      await applyCanvasToScreen();
      // we can revoke now that the image is drawn
      revokeOldUrl();
    };
    imgEl.onerror = (e) => {
      status('Failed to read image. Try a different file.'); console.error(e);
    };
    imgEl.src = objectUrl;
  } catch (e) {
    status('Failed to handle image.'); console.error(e);
  }
});

// Live adjustments
[zoom, panX, panY, emissive].forEach(ctrl => {
  ctrl.addEventListener('input', () => {
    if (!imgEl) return;
    drawCoverToCanvas();
    applyCanvasToScreen();
  });
});

clearBtn.addEventListener('click', () => {
  if (!screenMat) return;
  const pbr = screenMat.pbrMetallicRoughness;
  if (pbr?.baseColorTexture?.setTexture) pbr.baseColorTexture.setTexture(null);
  else if (pbr?.setBaseColorTexture)     pbr.setBaseColorTexture(null);
  screenMat.emissiveTexture?.setTexture?.(null);
  clearBtn.disabled = true;
  imgEl = null;
  status('Cleared.');
});
</script>
</body>
</html>

