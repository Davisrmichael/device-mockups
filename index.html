<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mockup Maker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    :root { --panel: 320px; --gap: 18px; --bg:#eef0f3; --card:#fff; --muted:#667085; --accent:#0f62fe;}
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin:0; font:14px/1.2 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
           background: var(--bg); color:#111; }
    .app { display: grid; grid-template-columns: var(--panel) 1fr; height: 100%; }
    aside { padding: 18px; background:#f7f8fa; border-right:1px solid #e4e7ec; overflow:auto; }
    .h { font-weight:700; margin:0 0 12px; }
    .group { background:var(--card); border:1px solid #e7e9ef; border-radius:12px; padding:14px; margin-bottom:12px; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:10px 0; }
    .row label { color: var(--muted); font-size:12px; }
    input[type="range"] { width: 180px; }
    .btn { appearance:none; border:1px solid #d0d5dd; background:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; }
    .btn.primary { border-color: var(--accent); background: var(--accent); color:#fff; }
    .stack { display:flex; gap:8px; flex-wrap:wrap; }
    .note { color:var(--muted); font-size:12px; margin-top:8px; }
    main { display:grid; place-items:center; padding: var(--gap); }
    model-viewer { width: min(100%, 1100px); height: min(100%, 780px); background:#e6e9ee; border-radius:14px; }
    .toast { position: fixed; inset:auto 18px 18px auto; background:#111; color:#fff; padding:10px 12px; border-radius:8px; opacity:0; transform: translateY(6px); transition: .25s; pointer-events:none; }
    .toast.show { opacity:1; transform: translateY(0); }
    /* hide the worker canvas but keep it in DOM for toDataURL etc if needed */
    #work { position:absolute; left:-9999px; top:-9999px; }
  </style>
</head>
<body>
  <div class="app">
    <aside>
      <h2 class="h">Mockup Maker</h2>

      <div class="group">
        <div class="row" style="grid-template-columns: 1fr;">
          <button class="btn" id="pick">Choose Image…</button>
          <input id="file" type="file" accept="image/*" hidden />
        </div>
        <label class="row">
          <span>Zoom</span>
          <input id="zoom" type="range" min="0.5" max="3.0" step="0.01" value="1.00" />
        </label>
        <label class="row">
          <span>Pan X</span>
          <input id="panx" type="range" min="-1" max="1" step="0.01" value="0" />
        </label>
        <label class="row">
          <span>Pan Y</span>
          <input id="pany" type="range" min="-1" max="1" step="0.01" value="0" />
        </label>
        <label class="row" title="Lights up the texture on screen">
          <span><input id="bright" type="checkbox" checked /> Bright (emissive)</span>
          <span></span>
        </label>

        <div class="stack" style="margin-top:8px;">
          <button class="btn" id="front">Front-on</button>
          <button class="btn" id="reset">Reset</button>
          <button class="btn primary" id="export">Export PNG</button>
        </div>
        <div class="note">Targets material named <b>Screen</b>. Image is drawn to a 720×720 canvas using
          <i>cover</i> (uniform scale) with sliders for zoom + pan.</div>
      </div>
    </aside>

    <main>
      <model-viewer id="mv"
        src="iPhone-15-pro-2/iPhone-15.gltf"
        ar ar-modes="webxr scene-viewer quick-look"
        camera-controls
        exposure="1"
        environment-image="neutral"
        shadow-intensity="0"
        interpolation-decay="200"
        tone-mapping="neutral"
        style="--poster-color: transparent;"
      ></model-viewer>
    </main>
  </div>

  <!-- hidden worker canvas used to build the texture -->
  <canvas id="work" width="720" height="720"></canvas>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script type="module">
    const mv    = document.getElementById('mv');
    const file  = document.getElementById('file');
    const pick  = document.getElementById('pick');
    const zoom  = document.getElementById('zoom');
    const panX  = document.getElementById('panx');
    const panY  = document.getElementById('pany');
    const bright= document.getElementById('bright');
    const front = document.getElementById('front');
    const reset = document.getElementById('reset');
    const exportBtn = document.getElementById('export');
    const work  = document.getElementById('work');
    const toast = document.getElementById('toast');

    let objectUrl; // for image File -> object URL lifecycle
    let lastImage; // HTMLImageElement once loaded

    function say(msg, ok=true) {
      toast.textContent = msg;
      toast.style.background = ok ? '#111' : '#b42318';
      toast.classList.add('show');
      setTimeout(()=>toast.classList.remove('show'), 1800);
    }

    pick.addEventListener('click', ()=> file.click());

    file.addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try {
        lastImage = await fileToImage(f);           // load via object URL (no canvas src!)
        drawAndApply();                              // draw to canvas & push to model
      } catch (err) {
        console.error(err);
        say('Failed to load image', false);
      }
    });

    // Redraw when controls change
    [zoom, panX, panY, bright].forEach(el => el.addEventListener('input', () => {
      if (lastImage) drawAndApply();
    }));

    front.addEventListener('click', () => {
      // Face the camera straight-on; keep distance roughly consistent
      mv.cameraOrbit = '0deg 90deg 0%';
      mv.fieldOfView = '30deg';
    });

    reset.addEventListener('click', () => {
      zoom.value = '1';
      panX.value = '0';
      panY.value = '0';
      mv.cameraOrbit = '0deg 75deg 105%';
      if (lastImage) drawAndApply();
    });

    exportBtn.addEventListener('click', async () => {
      try {
        const blob = await work.convertToBlob ? await work.convertToBlob({type:'image/png'}) :
                     await new Promise(r => work.toBlob(r, 'image/png'));
        const a = document.createElement('a');
        a.download = 'mockup-screen.png';
        a.href = URL.createObjectURL(blob);
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (err) {
        console.error(err);
        say('Export failed', false);
      }
    });

    // ---------------- core helpers ----------------

    function fileToImage(file) {
      if (objectUrl) URL.revokeObjectURL(objectUrl);
      objectUrl = URL.createObjectURL(file);
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.decoding = 'sync';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.crossOrigin = 'anonymous';
        img.src = objectUrl;       // ✅ real URL, never canvas
      });
    }

    function drawCoverToCanvas(img, canvas, zoom=1, panX=0, panY=0) {
      const ctx = canvas.getContext('2d');
      const dw = canvas.width, dh = canvas.height;
      const sw = img.naturalWidth, sh = img.naturalHeight;

      // uniform scale: cover
      const s = Math.max(dw/sw, dh/sh) * zoom;
      const tw = sw * s, th = sh * s;

      // pan within the overflow region; panX/panY in [-1,1]
      const maxX = Math.max(0, tw - dw);
      const maxY = Math.max(0, th - dh);
      const ox = (maxX * 0.5) * panX;
      const oy = (maxY * 0.5) * panY;

      ctx.clearRect(0,0,dw,dh);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,dw,dh);

      // Flip Y so the GL texture appears upright
      ctx.save();
      ctx.translate(0, dh);
      ctx.scale(1, -1);

      const dx = (dw - tw)/2 + ox;
      const dy = (dh - th)/2 + oy;
      ctx.drawImage(img, dx, dy, tw, th);
      ctx.restore();
    }

    async function drawAndApply() {
      drawCoverToCanvas(
        lastImage, work,
        parseFloat(zoom.value),
        parseFloat(panX.value),
        parseFloat(panY.value)
      );
      await applyCanvasToScreen();
    }

    async function applyCanvasToScreen() {
      try {
        // Create a WebGL texture from the canvas
        const tex = await mv.createTexture(work);

        // Find material named "Screen"
        const mat = mv.model?.materials?.find(m => m.name === 'Screen');
        if (!mat) { say('Screen material not found', false); return; }

        // Prefer emissive when "bright" is on
        const useEmissive = bright.checked;

        // Version-safe setters across model-viewer versions:
        const pmr = mat.pbrMetallicRoughness;

        const setBase = () => {
          if (pmr?.baseColorTexture?.setTexture) return pmr.baseColorTexture.setTexture(tex);
          if (pmr?.setBaseColorTexture)          return pmr.setBaseColorTexture(tex);
          if (mat?.setBaseColorTexture)          return mat.setBaseColorTexture(tex);
        };

        const setEmissive = () => {
          if (mat?.emissiveTexture?.setTexture)  return mat.emissiveTexture.setTexture(tex);
          if (mat?.setEmissiveTexture)           return mat.setEmissiveTexture(tex);
        };

        // Set factors safely if the API supports setters
        const setEmissiveFactor = (v) => {
          if (typeof mat?.setEmissiveFactor === 'function') mat.setEmissiveFactor(v);
          else if ('emissiveFactor' in mat) mat.emissiveFactor = v;
        };

        if (useEmissive && (mat.emissiveTexture || mat.setEmissiveTexture)) {
          setEmissive();
          setEmissiveFactor([1,1,1]);
        } else {
          setBase();
        }

        // Nudge PBR so the image reads cleanly (only if setters exist)
        if (pmr?.setMetallicFactor) pmr.setMetallicFactor(0.0);
        if (pmr?.setRoughnessFactor) pmr.setRoughnessFactor(0.9);

        say('Screen updated');
      } catch (err) {
        console.error(err);
        say('Failed to apply image. Try another file / refresh.', false);
      }
    }
  </script>
</body>
</html>
